<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PixiJS: Light, Attracted Bugs</title>
    <style>
      body {
        margin: 0;
        overflow: hidden; /* Prevent scrollbars */
        background-color: #000;
        cursor: none; /* Hide default browser cursor */
        font-family: 'Inter', sans-serif; /* Apply Inter font */
      }
      canvas {
        display: block; /* Remove extra space below canvas */
      }
      /* Removed .loading-message style as it's no longer needed */
      /* Google Fonts - Inter */
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    </style>
  </head>
  <body>
    <!-- Removed <div class="loading-message" id="loadingMessage">Loading secrets and bugs...</div> -->

    <!-- Load PixiJS v8 library -->
    <script src="https://cdn.jsdelivr.net/npm/pixi@8.1.1/dist/pixi.min.js"></script>

    <script type="module">
      // Import necessary PixiJS v8 modules
      import {
        Application,
        Graphics,
        Sprite,
        Point,
        Texture,
      } from 'https://cdn.jsdelivr.net/npm/pixi@8.1.1/dist/pixi.mjs';

      // Ensure the window is fully loaded before initializing PixiJS
      window.onload = async function () {
        // const loadingMessage = document.getElementById('loadingMessage'); // Removed

        // 1. Create a PixiJS Application
        const app = new Application({
          width: window.innerWidth,
          height: window.innerHeight,
          backgroundColor: 0x1a1a1a, // A very dark gray, almost black
          autoDensity: true,
          resolution: window.devicePixelRatio || 1,
        });

        // Add the PixiJS canvas to the document body
        document.body.appendChild(app.canvas);

        // Set the stage interactive to enable mouse events
        app.stage.eventMode = 'static';

        // --- Constants for the application ---
        const LIGHT_RADIUS = 200; // Radius of the light effect
        const LIGHT_REVEAL_RADIUS = 250; // Distance from light center to reveal a bug
        const BUG_COUNT = 30; // Number of bugs
        const BUG_SPEED = 1.5; // Base speed of bugs
        const BUG_ATTRACTION_FORCE = 0.05; // How strongly bugs are attracted to light
        const BUG_RANDOM_FORCE = 0.05; // Randomness in bug movement

        // --- Global variables for light and elements ---
        let lightMask;
        let darkOverlay;
        let backgroundContainer;
        let bugs = []; // Array to hold bug objects
        // let secretsData = []; // Removed: To store generated secrets and their Pixi Text objects
        let mousePos = new Point(app.screen.width / 2, app.screen.height / 2); // Initial mouse position

        // 2. Function to generate a radial gradient texture for the light mask
        function generateRadialGradientTexture(radius) {
          const canvas = document.createElement('canvas');
          canvas.width = radius * 2;
          canvas.height = radius * 2;
          const ctx = canvas.getContext('2d');

          const gradient = ctx.createRadialGradient(radius, radius, 0, radius, radius, radius);

          gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
          gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          return Texture.from(canvas);
        }

        // 3. Create the Background Container and add tiled elements
        function createBackgroundTiles() {
          if (backgroundContainer) {
            backgroundContainer.destroy({ children: true }); // Clear and destroy previous container
          }
          backgroundContainer = new PIXI.Container();
          app.stage.addChild(backgroundContainer);

          const TILE_SIZE = 50;
          const TEXTURE_COLOR_1 = 0x333333; // Dark gray
          const TEXTURE_COLOR_2 = 0x444444; // Slightly lighter gray

          const numCols = Math.ceil(app.screen.width / TILE_SIZE);
          const numRows = Math.ceil(app.screen.height / TILE_SIZE);

          for (let i = 0; i < numCols; i++) {
            for (let j = 0; j < numRows; j++) {
              const rect = new Graphics();
              rect.beginFill((i + j) % 2 === 0 ? TEXTURE_COLOR_1 : TEXTURE_COLOR_2);
              rect.drawRect(0, 0, TILE_SIZE, TILE_SIZE);
              rect.endFill();
              rect.x = i * TILE_SIZE;
              rect.y = j * TILE_SIZE;
              backgroundContainer.addChild(rect);
            }
          }
        }

        // 4. Create the Dark Overlay and Light Mask
        function setupLighting() {
          if (darkOverlay) {
            darkOverlay.destroy();
          }
          darkOverlay = new Graphics();
          darkOverlay.beginFill(0x000000, 0.98); // Slightly darker overlay
          darkOverlay.drawRect(0, 0, app.screen.width, app.screen.height);
          darkOverlay.endFill();
          app.stage.addChild(darkOverlay); // Add overlay *above* the background

          // Generate and setup light mask
          const lightTexture = generateRadialGradientTexture(LIGHT_RADIUS);
          if (lightMask) {
            lightMask.destroy();
          }
          lightMask = new Sprite(lightTexture);
          lightMask.anchor.setter(0.5);
          lightMask.width = LIGHT_RADIUS * 2;
          lightMask.height = LIGHT_RADIUS * 2;
          app.stage.addChild(lightMask);

          darkOverlay.mask = lightMask;
        }

        // 5. Bug Class/Object
        class Bug extends Graphics {
          constructor() {
            super();
            this.beginFill(0x888888); // Gray bug
            this.drawCircle(0, 0, 4); // Small bug size
            this.endFill();
            this.x = Math.random() * app.screen.width;
            this.y = Math.random() * app.screen.height;
            this.vx = (Math.random() - 0.5) * BUG_SPEED; // Random initial velocity
            this.vy = (Math.random() - 0.5) * BUG_SPEED;
            this.alpha = 0; // Bugs start invisible
            this.revealed = false; // Internal state for visibility logic
          }

          update(lightX, lightY) {
            // Vector from bug to light
            let dx = lightX - this.x;
            let dy = lightY - this.y;
            let dist = Math.sqrt(dx * dx + dy * dy);

            // Normalize direction and apply attraction force
            if (dist > 1) {
              // Avoid division by zero when dist is very small
              dx /= dist;
              dy /= dist;
              this.vx += dx * BUG_ATTRACTION_FORCE;
              this.vy += dy * BUG_ATTRACTION_FORCE;
            }

            // Add random movement
            this.vx += (Math.random() - 0.5) * BUG_RANDOM_FORCE;
            this.vy += (Math.random() - 0.5) * BUG_RANDOM_FORCE;

            // Limit speed
            let currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (currentSpeed > BUG_SPEED) {
              this.vx = (this.vx / currentSpeed) * BUG_SPEED;
              this.vy = (this.vy / currentSpeed) * BUG_SPEED;
            }

            // Update position
            this.x += this.vx;
            this.y += this.vy;

            // Keep bugs within screen bounds
            if (this.x < 0 || this.x > app.screen.width) this.vx *= -1;
            if (this.y < 0 || this.y > app.screen.height) this.vy *= -1;
            this.x = Math.max(0, Math.min(app.screen.width, this.x));
            this.y = Math.max(0, Math.min(app.screen.height, this.y));

            // Fade in/out based on light proximity
            if (dist < LIGHT_REVEAL_RADIUS) {
              this.alpha = Math.min(1, this.alpha + 0.05); // Fade in
              this.revealed = true;
            } else {
              // Fade out if it was revealed and light moves away
              if (this.revealed) {
                this.alpha = Math.max(0, this.alpha - 0.02); // Fade out slower
                if (this.alpha === 0) this.revealed = false; // Reset if fully faded
              }
            }
          }
        }

        // 6. Initialize Bugs
        function initBugs() {
          bugs.forEach((bug) => bug.destroy()); // Destroy existing bugs
          bugs = [];
          for (let i = 0; i < BUG_COUNT; i++) {
            const bug = new Bug();
            app.stage.addChild(bug); // Add bugs to the stage
            bugs.push(bug);
          }
        }

        // Removed: 7. Function to fetch secrets from Gemini API
        // Removed: 8. Function to place secrets as Pixi Text objects

        // --- Initial Setup Execution ---
        createBackgroundTiles();
        setupLighting();
        initBugs(); // Initialize bugs

        // Removed: Fetch and place secrets after initial setup
        // const generatedSecrets = await fetchSecrets();
        // await placeSecrets(generatedSecrets);
        // loadingMessage.style.display = 'none'; // Removed

        // 9. Mouse Move Listener
        app.stage.on('pointermove', (event) => {
          mousePos.setter(event.client.x, event.client.y);
        });

        // 10. PixiJS Animation Loop (Ticker)
        app.ticker.add((time) => {
          const delta = time.deltaTime;

          // Update light mask position
          lightMask.x = mousePos.x;
          lightMask.y = mousePos.y;

          // Update bugs
          bugs.forEach((bug) => {
            bug.update(mousePos.x, mousePos.y);
          });

          // Removed: Update secret messages visibility logic
        });

        // 11. Handle Window Resizing
        window.addEventListener('resize', async () => {
          app.renderer.resize(window.innerWidth, window.innerHeight);

          // Re-create background tiles to fit new size
          createBackgroundTiles();

          // Re-position dark overlay and mask
          darkOverlay.width = app.screen.width;
          darkOverlay.height = app.screen.height;

          // Re-initialize bugs for new positions/bounds
          initBugs();

          // Removed: Re-fetch and re-place secrets for new random positions
          // const newSecrets = await fetchSecrets();
          // await placeSecrets(newSecrets);
        });
      };
    </script>
  </body>
</html>
